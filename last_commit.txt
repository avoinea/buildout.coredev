Repository: Products.CMFPlone


Branch: refs/heads/5.1.x
Date: 2020-02-11T21:01:04+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/e6fefadf084be3c0d20149d7c8b6250a738191b5

Password strength checks were not always checked

Include Hotfix 20200121 with tests

Files changed:
A news/3021.bugfix.1
M Products/CMFPlone/RegistrationTool.py
M Products/CMFPlone/tests/testControlPanelScripts.py
M Products/CMFPlone/tests/testRegistrationTool.py

b'diff --git a/Products/CMFPlone/RegistrationTool.py b/Products/CMFPlone/RegistrationTool.py\nindex c4dbf71887..10c10f69c8 100644\n--- a/Products/CMFPlone/RegistrationTool.py\n+++ b/Products/CMFPlone/RegistrationTool.py\n@@ -173,7 +173,7 @@ def testPasswordValidity(self, password, confirm=None):\n         # o If the password is valid, return None.\n         # o If not, return a string explaining why.\n         err = self.pasValidation(\'password\', password)\n-        if err and (password == \'\' or not _checkPermission(ManagePortal, self)):\n+        if err:\n             return err\n \n         if confirm is not None and confirm != password:\ndiff --git a/Products/CMFPlone/tests/testControlPanelScripts.py b/Products/CMFPlone/tests/testControlPanelScripts.py\nindex fc86bc467b..e35cfdd5b8 100644\n--- a/Products/CMFPlone/tests/testControlPanelScripts.py\n+++ b/Products/CMFPlone/tests/testControlPanelScripts.py\n@@ -38,7 +38,8 @@ def _onlyPOST(self, path, qstring=\'\', success=200, rpath=None):\n \n     def test_loginChangePassword(self):\n         path = self.folder_path + \'/login_change_password\'\n-        qstring = \'password=foo\'\n+        # Note: needs to be at least five characters.\n+        qstring = \'password=foobar\'\n         self._onlyPOST(path, qstring)\n \n \ndiff --git a/Products/CMFPlone/tests/testRegistrationTool.py b/Products/CMFPlone/tests/testRegistrationTool.py\nindex 5042b91102..07471f404a 100644\n--- a/Products/CMFPlone/tests/testRegistrationTool.py\n+++ b/Products/CMFPlone/tests/testRegistrationTool.py\n@@ -95,6 +95,26 @@ def testTestPasswordValidityConfirm(self):\n         self.assertFalse(self.registration.testPasswordValidity(\n             \'validpassword\', confirm=\'anotherpassword\') is None)\n \n+    def testTestPasswordValidityPolicy(self):\n+        self.assertIsNone(self.registration.testPasswordValidity("abcde", confirm=None))\n+        self.assertEqual(\n+            self.registration.testPasswordValidity("abcd", confirm=None),\n+            "Your password must contain at least 5 characters.",\n+        )\n+        # Password validity is checked with an empty password\n+        # to get a nice help message to show for the input field.\n+        self.assertEqual(\n+            self.registration.testPasswordValidity("", confirm=None),\n+            "Minimum 5 characters.",\n+        )\n+\n+    def testPasValidation(self):\n+        self.assertIsNone(self.registration.pasValidation("password", "abcde"))\n+        self.assertEqual(\n+            self.registration.pasValidation("password", "abcd"),\n+            "Your password must contain at least 5 characters.",\n+        )\n+\n     def testNewIdAllowed(self):\n         self.assertEqual(self.registration.isMemberIdAllowed(\'newuser\'), 1)\n \ndiff --git a/news/3021.bugfix.1 b/news/3021.bugfix.1\nnew file mode 100644\nindex 0000000000..23fa8a5e79\n--- /dev/null\n+++ b/news/3021.bugfix.1\n@@ -0,0 +1 @@\n+Merge Hotfix20200121 Check of the strength of password could be skipped.\n'

Repository: Products.CMFPlone


Branch: refs/heads/5.1.x
Date: 2020-02-11T21:04:17+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/4e4e7c3c7b01f56ab6a817ac7e39929b399ed9f6

Merge isURLInPortal patch from Hotfix20200121.

The isURLInPortal check that is done to avoid linking to an external
site could be tricked into accepting malicious links.

Files changed:
A news/3021.bugfix.2
M Products/CMFPlone/URLTool.py
M Products/CMFPlone/tests/testURLTool.py

b'diff --git a/Products/CMFPlone/URLTool.py b/Products/CMFPlone/URLTool.py\nindex b489f5f9ba..007a6ac29f 100644\n--- a/Products/CMFPlone/URLTool.py\n+++ b/Products/CMFPlone/URLTool.py\n@@ -10,6 +10,8 @@\n from urlparse import urlparse, urljoin\n from zope.component import getUtility\n import re\n+import string\n+import unicodedata\n \n \n hp = HTMLParser()\n@@ -30,6 +32,62 @@\n     \'javascript%3a\',\n ]\n \n+# Determine allowed ascii characters.\n+# We want to allow most printable characters,\n+# but no whitespace, and no punctuation, except for a few exceptions.\n+# This boils down to ascii letters plus digits plus exceptions.\n+# Exceptions:\n+# - dot and slash for relative or absolute paths.\n+# - @ because we have views starting with @@\n+# - + because we have ++resource++ urls\n+allowed_ascii = string.ascii_letters + string.digits + "./@+"\n+\n+def safe_url_first_char(url):\n+    # For character code points higher than 127, the bytes representation of a character\n+    # is longer than the unicode representation, so url[0] may give different results\n+    # for bytes and unicode.  On Python 2:\n+    # >>> unichr(128)\n+    # u\'\\x80\'\n+    # >>> len(unichr(128))\n+    # 1\n+    # >>> unichr(128).encode("latin-1")\n+    # \'\\x80\'\n+    # >>> len(unichr(128).encode("latin-1"))\n+    # 1\n+    # >>> unichr(128).encode("utf-8")\n+    # \'\\xc2\\x80\'\n+    # >>> len(unichr(128).encode("utf-8"))\n+    # 2\n+    # >>> unichr(128).encode("utf-8")[0]\n+    # \'\\xc2\'\n+    # So make sure we have unicode here for comparing the first character.\n+    if isinstance(url, bytes):\n+        # Remember, on Python 2, bytes == str.\n+        try:\n+            first = url.decode("utf-8")[0]\n+        except UnicodeDecodeError:\n+            # We don\'t trust this\n+            return False\n+    else:\n+        first = url[0]\n+    if ord(first) < 128:\n+        if first not in allowed_ascii:\n+            # The first character of the url is ascii but not in the allowed range.\n+            return False\n+    else:\n+        # This is non-ascii, which has lots of control characters, which may be dangerous.\n+        # Check taken from django.utils.http._is_safe_url.  See\n+        # https://github.com/django/django/blob/2.1.5/django/utils/http.py#L356-L382\n+        # Forbid URLs that start with control characters. Some browsers (like\n+        # Chrome) ignore quite a few control characters at the start of a\n+        # URL and might consider the URL as scheme relative.\n+        # For categories, see 5.7.1 General Category Values here:\n+        # http://www.unicode.org/reports/tr44/tr44-6.html#Property_Values\n+        # We look for Control categories here.\n+        if unicodedata.category(first)[0] == "C":\n+            return False\n+    return True\n+\n \n class URLTool(PloneBaseTool, BaseTool):\n \n@@ -51,6 +109,9 @@ def isURLInPortal(self, url, context=None):\n         # site_properties are also considered within the portal to allow for\n         # single sign on.\n \n+        if url and not safe_url_first_char(url):\n+            return False\n+\n         # sanitize url\n         url = re.sub(\'^[\\x00-\\x20]+\', \'\', url).strip()\n         cmp_url = url.lower()\ndiff --git a/Products/CMFPlone/tests/testURLTool.py b/Products/CMFPlone/tests/testURLTool.py\nindex bfa1bf1185..8c6e3dcf02 100644\n--- a/Products/CMFPlone/tests/testURLTool.py\n+++ b/Products/CMFPlone/tests/testURLTool.py\n@@ -68,6 +68,7 @@ def test_isURLInPortal(self):\n         self.assertTrue(iURLiP(\'https://www.foobar.com/bar/foo/folder\'))\n         self.assertFalse(iURLiP(\'http://www.foobar.com:8080/bar/foo/folder\'))\n         self.assertFalse(iURLiP(\'http://www.foobar.com/bar\'))\n+        self.assertTrue(iURLiP(\'//www.foobar.com/bar/foo\'))\n         self.assertFalse(iURLiP(\'/images\'))\n         self.assertTrue(iURLiP(\'/bar/foo/foo\'))\n \n@@ -137,6 +138,15 @@ def test_double_back_slash(self):\n         iURLiP = url_tool.isURLInPortal\n         self.assertFalse(iURLiP(\'\\\\\\\\www.example.com\'))\n \n+    def test_escape(self):\n+        url_tool = self._makeOne()\n+        iURLiP = url_tool.isURLInPortal\n+        self.assertFalse(iURLiP(\'\\/\\/www.example.com\'))\n+        self.assertFalse(iURLiP(\'\\%2F\\%2Fwww.example.com\'))\n+        self.assertFalse(iURLiP(\'\\%2f\\%2fwww.example.com\'))\n+        self.assertFalse(iURLiP(\'%2F%2Fwww.example.com\'))\n+        self.assertFalse(iURLiP(\'%2f%2fwww.example.com\'))\n+\n     def test_regression_absolute_url_in_portal(self):\n         url_tool = self._makeOne()\n         iURLiP = url_tool.isURLInPortal\ndiff --git a/news/3021.bugfix.2 b/news/3021.bugfix.2\nnew file mode 100644\nindex 0000000000..b48698a2db\n--- /dev/null\n+++ b/news/3021.bugfix.2\n@@ -0,0 +1 @@\n+Merge Hotfix20200121: isURLInPortal could be tricked into accepting malicious links.\n'

Repository: Products.CMFPlone


Branch: refs/heads/5.1.x
Date: 2020-02-26T16:59:03+01:00
Author: Alessandro Pisa (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/Products.CMFPlone/commit/81fa52f7865e83622bbdf2c83460d1ad176ac048

Merge pull request #3043 from plone/maurits-plonehotfix2020-password-inportal-51

Merge PloneHotfix20200121 isURLInPortal and password strength [5.1]

Files changed:
A news/3021.bugfix.1
A news/3021.bugfix.2
M Products/CMFPlone/RegistrationTool.py
M Products/CMFPlone/URLTool.py
M Products/CMFPlone/tests/testControlPanelScripts.py
M Products/CMFPlone/tests/testRegistrationTool.py
M Products/CMFPlone/tests/testURLTool.py

b'diff --git a/Products/CMFPlone/RegistrationTool.py b/Products/CMFPlone/RegistrationTool.py\nindex c4dbf71887..10c10f69c8 100644\n--- a/Products/CMFPlone/RegistrationTool.py\n+++ b/Products/CMFPlone/RegistrationTool.py\n@@ -173,7 +173,7 @@ def testPasswordValidity(self, password, confirm=None):\n         # o If the password is valid, return None.\n         # o If not, return a string explaining why.\n         err = self.pasValidation(\'password\', password)\n-        if err and (password == \'\' or not _checkPermission(ManagePortal, self)):\n+        if err:\n             return err\n \n         if confirm is not None and confirm != password:\ndiff --git a/Products/CMFPlone/URLTool.py b/Products/CMFPlone/URLTool.py\nindex b489f5f9ba..007a6ac29f 100644\n--- a/Products/CMFPlone/URLTool.py\n+++ b/Products/CMFPlone/URLTool.py\n@@ -10,6 +10,8 @@\n from urlparse import urlparse, urljoin\n from zope.component import getUtility\n import re\n+import string\n+import unicodedata\n \n \n hp = HTMLParser()\n@@ -30,6 +32,62 @@\n     \'javascript%3a\',\n ]\n \n+# Determine allowed ascii characters.\n+# We want to allow most printable characters,\n+# but no whitespace, and no punctuation, except for a few exceptions.\n+# This boils down to ascii letters plus digits plus exceptions.\n+# Exceptions:\n+# - dot and slash for relative or absolute paths.\n+# - @ because we have views starting with @@\n+# - + because we have ++resource++ urls\n+allowed_ascii = string.ascii_letters + string.digits + "./@+"\n+\n+def safe_url_first_char(url):\n+    # For character code points higher than 127, the bytes representation of a character\n+    # is longer than the unicode representation, so url[0] may give different results\n+    # for bytes and unicode.  On Python 2:\n+    # >>> unichr(128)\n+    # u\'\\x80\'\n+    # >>> len(unichr(128))\n+    # 1\n+    # >>> unichr(128).encode("latin-1")\n+    # \'\\x80\'\n+    # >>> len(unichr(128).encode("latin-1"))\n+    # 1\n+    # >>> unichr(128).encode("utf-8")\n+    # \'\\xc2\\x80\'\n+    # >>> len(unichr(128).encode("utf-8"))\n+    # 2\n+    # >>> unichr(128).encode("utf-8")[0]\n+    # \'\\xc2\'\n+    # So make sure we have unicode here for comparing the first character.\n+    if isinstance(url, bytes):\n+        # Remember, on Python 2, bytes == str.\n+        try:\n+            first = url.decode("utf-8")[0]\n+        except UnicodeDecodeError:\n+            # We don\'t trust this\n+            return False\n+    else:\n+        first = url[0]\n+    if ord(first) < 128:\n+        if first not in allowed_ascii:\n+            # The first character of the url is ascii but not in the allowed range.\n+            return False\n+    else:\n+        # This is non-ascii, which has lots of control characters, which may be dangerous.\n+        # Check taken from django.utils.http._is_safe_url.  See\n+        # https://github.com/django/django/blob/2.1.5/django/utils/http.py#L356-L382\n+        # Forbid URLs that start with control characters. Some browsers (like\n+        # Chrome) ignore quite a few control characters at the start of a\n+        # URL and might consider the URL as scheme relative.\n+        # For categories, see 5.7.1 General Category Values here:\n+        # http://www.unicode.org/reports/tr44/tr44-6.html#Property_Values\n+        # We look for Control categories here.\n+        if unicodedata.category(first)[0] == "C":\n+            return False\n+    return True\n+\n \n class URLTool(PloneBaseTool, BaseTool):\n \n@@ -51,6 +109,9 @@ def isURLInPortal(self, url, context=None):\n         # site_properties are also considered within the portal to allow for\n         # single sign on.\n \n+        if url and not safe_url_first_char(url):\n+            return False\n+\n         # sanitize url\n         url = re.sub(\'^[\\x00-\\x20]+\', \'\', url).strip()\n         cmp_url = url.lower()\ndiff --git a/Products/CMFPlone/tests/testControlPanelScripts.py b/Products/CMFPlone/tests/testControlPanelScripts.py\nindex fc86bc467b..e35cfdd5b8 100644\n--- a/Products/CMFPlone/tests/testControlPanelScripts.py\n+++ b/Products/CMFPlone/tests/testControlPanelScripts.py\n@@ -38,7 +38,8 @@ def _onlyPOST(self, path, qstring=\'\', success=200, rpath=None):\n \n     def test_loginChangePassword(self):\n         path = self.folder_path + \'/login_change_password\'\n-        qstring = \'password=foo\'\n+        # Note: needs to be at least five characters.\n+        qstring = \'password=foobar\'\n         self._onlyPOST(path, qstring)\n \n \ndiff --git a/Products/CMFPlone/tests/testRegistrationTool.py b/Products/CMFPlone/tests/testRegistrationTool.py\nindex 5042b91102..07471f404a 100644\n--- a/Products/CMFPlone/tests/testRegistrationTool.py\n+++ b/Products/CMFPlone/tests/testRegistrationTool.py\n@@ -95,6 +95,26 @@ def testTestPasswordValidityConfirm(self):\n         self.assertFalse(self.registration.testPasswordValidity(\n             \'validpassword\', confirm=\'anotherpassword\') is None)\n \n+    def testTestPasswordValidityPolicy(self):\n+        self.assertIsNone(self.registration.testPasswordValidity("abcde", confirm=None))\n+        self.assertEqual(\n+            self.registration.testPasswordValidity("abcd", confirm=None),\n+            "Your password must contain at least 5 characters.",\n+        )\n+        # Password validity is checked with an empty password\n+        # to get a nice help message to show for the input field.\n+        self.assertEqual(\n+            self.registration.testPasswordValidity("", confirm=None),\n+            "Minimum 5 characters.",\n+        )\n+\n+    def testPasValidation(self):\n+        self.assertIsNone(self.registration.pasValidation("password", "abcde"))\n+        self.assertEqual(\n+            self.registration.pasValidation("password", "abcd"),\n+            "Your password must contain at least 5 characters.",\n+        )\n+\n     def testNewIdAllowed(self):\n         self.assertEqual(self.registration.isMemberIdAllowed(\'newuser\'), 1)\n \ndiff --git a/Products/CMFPlone/tests/testURLTool.py b/Products/CMFPlone/tests/testURLTool.py\nindex bfa1bf1185..8c6e3dcf02 100644\n--- a/Products/CMFPlone/tests/testURLTool.py\n+++ b/Products/CMFPlone/tests/testURLTool.py\n@@ -68,6 +68,7 @@ def test_isURLInPortal(self):\n         self.assertTrue(iURLiP(\'https://www.foobar.com/bar/foo/folder\'))\n         self.assertFalse(iURLiP(\'http://www.foobar.com:8080/bar/foo/folder\'))\n         self.assertFalse(iURLiP(\'http://www.foobar.com/bar\'))\n+        self.assertTrue(iURLiP(\'//www.foobar.com/bar/foo\'))\n         self.assertFalse(iURLiP(\'/images\'))\n         self.assertTrue(iURLiP(\'/bar/foo/foo\'))\n \n@@ -137,6 +138,15 @@ def test_double_back_slash(self):\n         iURLiP = url_tool.isURLInPortal\n         self.assertFalse(iURLiP(\'\\\\\\\\www.example.com\'))\n \n+    def test_escape(self):\n+        url_tool = self._makeOne()\n+        iURLiP = url_tool.isURLInPortal\n+        self.assertFalse(iURLiP(\'\\/\\/www.example.com\'))\n+        self.assertFalse(iURLiP(\'\\%2F\\%2Fwww.example.com\'))\n+        self.assertFalse(iURLiP(\'\\%2f\\%2fwww.example.com\'))\n+        self.assertFalse(iURLiP(\'%2F%2Fwww.example.com\'))\n+        self.assertFalse(iURLiP(\'%2f%2fwww.example.com\'))\n+\n     def test_regression_absolute_url_in_portal(self):\n         url_tool = self._makeOne()\n         iURLiP = url_tool.isURLInPortal\ndiff --git a/news/3021.bugfix.1 b/news/3021.bugfix.1\nnew file mode 100644\nindex 0000000000..23fa8a5e79\n--- /dev/null\n+++ b/news/3021.bugfix.1\n@@ -0,0 +1 @@\n+Merge Hotfix20200121 Check of the strength of password could be skipped.\ndiff --git a/news/3021.bugfix.2 b/news/3021.bugfix.2\nnew file mode 100644\nindex 0000000000..b48698a2db\n--- /dev/null\n+++ b/news/3021.bugfix.2\n@@ -0,0 +1 @@\n+Merge Hotfix20200121: isURLInPortal could be tricked into accepting malicious links.\n'

